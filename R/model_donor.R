#' Model for donor-based imputation
#'
#' This function is intended to be used inside of [impute_unsupervised()] as
#' `model_fun`.
#'
#' @inheritParams impute_supervised
#' @param i index for row of `ds` or `NULL`
#' @param model_arg a list with two named elements (missing elements will be
#'   replaced by default values):
#'   * `selection` How to select the donors? Possible choices are:
#'     `complete_rows` (default), `partly_complete_rows`, `knn_complete_rows`,
#'     `knn_partly_complete_rows`
#' * `k` number of selected closest donor (default: 10), only used for knn
#'   `selection`s
#'
#' @return A "model" for [predict_donor()] which is merely a data frame.
#' @export
#' @importFrom gower gower_topn
#' @importFrom stats complete.cases
model_donor <- function(ds, M, i = NULL, model_arg = NULL) {
  if (is.null(model_arg)) {
    model_arg <- list()
  }
  stopifnot("model_arg must be a list or NULL" = is.list(model_arg))
  donor_selection <- ifelse(is.null(model_arg$selection), "complete_rows", model_arg$selection)
  donor_k <- ifelse(is.null(model_arg$k), 10, model_arg$k)
  if (is.null(i) && donor_selection != "complete_rows") {
    stop ("only 'donor_selection = \"complete_rows\"' is possible for this case")
  }
  if (donor_selection %in% c("complete_rows", "knn_complete_rows")) {
    suitable_rows <- complete.cases(ds)
  } else if(donor_selection %in% c("partly_complete_rows", "knn_partly_complete_rows")) {
    suitable_rows <- apply(M, 1, function(x) !any(M[i, ] & x))
  } else {
    stop(paste0("'", donor_selection, "' is not a valid option for donor_selection"))
  }
  if (donor_selection %in% c("knn_complete_rows", "knn_partly_complete_rows")) {
    suitable_rows_ind <- which(suitable_rows)
    best_k <- gower::gower_topn(ds[i, ], ds[suitable_rows, ], n = donor_k)$index[, 1]
    suitable_rows <- suitable_rows_ind[best_k]
  }
  return(structure(ds[suitable_rows, ], donor_selection = donor_selection))
}

#' Prediction for donor-based imputation
#'
#' This function is intended to be used inside of [impute_unsupervised()] as `predict_fun`.
#'
#' @inheritParams model_donor
#' @param ds_donors data set with donors, normally generated by [model_donor()]
#' @param i index of row of `ds` which should be imputed
#' @param donor_aggregation type of donor aggregation. Can be one of
#'   'choose_random' and 'average'
#'
#' @return The imputation values for row `i`
#' @export
predict_donor <- function(ds_donors, ds, M, i, donor_aggregation = "choose_random") {
  if (donor_aggregation == "choose_random") {
    return(ds_donors[sample.int(nrow(ds_donors), 1), M[i, ]])
  } else if (donor_aggregation == "average") {
    return(colMeans(ds_donors[ , M[i, ], drop = FALSE]))
  }
}
