% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/impute_iterative.R
\name{impute_iterative}
\alias{impute_iterative}
\title{Iterative imputation}
\usage{
impute_iterative(
  ds,
  model_spec_parsnip = linear_reg(),
  max_iter = 10,
  stop_fun = NULL,
  initial_imputation_fun = NULL,
  cols_used_for_imputation = "all",
  cols_order = seq_len(ncol(ds)),
  rows_used_for_imputation = "all",
  rows_order = seq_len(nrow(ds)),
  update_model = "each_column",
  update_ds_model = "each_column",
  stop_fun_args = NULL,
  M = is.na(ds),
  show_warning_incomplete_imputation = TRUE,
  ...
)
}
\arguments{
\item{ds}{the data set to be imputed, must be a data frame with column names}

\item{model_spec_parsnip}{The model type used for imputation. It is defined
via the \code{parsnip} package.}

\item{max_iter}{maximum number of iterations}

\item{stop_fun}{a stopping function (see details below) or \code{NULL}. If \code{NULL},
iterations are only stopped after \code{max_iter} is reached.}

\item{initial_imputation_fun}{This function will do the initial imputation of
the missing values. If \code{NULL}, no initial imputation is done. Some common
choices like mean imputation are implemented in the package missMethods.}

\item{cols_used_for_imputation}{Which columns should be used to impute other
columns? Possible choices: "only_complete", "already_imputed", "all"}

\item{cols_order}{ordering of the columns for imputation. This can be a vector with
indices or an \code{order_option} from \code{\link[=order_cols]{order_cols()}}.}

\item{rows_used_for_imputation}{Which rows should be used to impute other
rows? Possible choices: "only_complete", "partly_complete", "complete_in_k",
"already_imputed", "all_except_i", "all"}

\item{rows_order}{Ordering of the rows for imputation. This can be a vector with
indices or an \code{order_option} from \code{\link[=order_rows]{order_rows()}}.}

\item{update_model}{How often should the model for imputation be updated?
Possible choices are: "everytime" (after every imputed value),
"each_column" (only one update per column) and "every_iteration" (an alias
for "each_column").}

\item{update_ds_model}{How often should the data set for the inner model be
updated? Possible choices are: "everytime" (after every imputed value),
"each_column" (only one update per column) and "every_iteration".}

\item{stop_fun_args}{Further arguments passed on to \code{stop_fun}.}

\item{M}{missing data indicator matrix}

\item{show_warning_incomplete_imputation}{Should a warning be given, if the
returned data set still contains \code{NA}?}

\item{...}{Further arguments passed on to \code{\link[stats:predict]{stats::predict()}}.}
}
\value{
an imputed data set.
}
\description{
Iterative imputation of a data set
}
\section{stop_fun}{
 The \code{stop_fun} should take the arguments \code{ds} (the data
set imputed in the current iteration), \code{ds_old} (the data set imputed in
the last iteration), a list (with named elements \code{M} \code{nr_iterations},
\code{max_iter}) and \code{stop_fun_args} in this order. The \code{stop_fun} must return
\code{FALSE} to allow for a next iteration. If \code{stop_fun} returns not \code{FALSE}
the iteration is stopped and the return value of \code{stop_fun} is returned as
result of \code{impute_iterative()}. Therefore, this return value should
normally include the imputed data set \code{ds} or \code{ds_old}.
}

\examples{
# ToDo
# simple example
# example using stop_ds_difference()
}
