% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/impute_iterative.R
\name{impute_iterative}
\alias{impute_iterative}
\title{Iterative imputation}
\usage{
impute_iterative(
  ds,
  model_spec_parsnip = linear_reg(),
  max_iter = 10,
  stop_fun = NULL,
  initial_imputation_fun = NULL,
  cols_used_for_imputation = "only_complete",
  cols_order = seq_len(ncol(ds)),
  rows_used_for_imputation = "only_complete",
  rows_order = seq_len(nrow(ds)),
  M = is.na(ds),
  ...
)
}
\arguments{
\item{ds}{the data set to be imputed, must be a data frame with column names}

\item{model_spec_parsnip}{The model type used for imputation. It is defined
via the \code{parsnip} package.}

\item{max_iter}{maximum number of iterations}

\item{stop_fun}{a stopping function (see details below) or \code{NULL}. If \code{NULL},
iterations are only stopped after \code{max_iter} is reached.}

\item{initial_imputation_fun}{This function will do the initial imputation of
the missing values. If \code{NULL}, no initial imputation is done. Some common
choices like mean imputation are implemented in the package missMethods.}

\item{cols_used_for_imputation}{Which columns should be used to impute other
columns? Possible choices: "only_complete", "already_imputed", "all", "all_no_update"}

\item{cols_order}{ordering of the columns for imputation. This can be a vector with
indices or an \code{order_option} from \code{\link[=order_cols]{order_cols()}}.}

\item{rows_used_for_imputation}{Which rows should be used to impute other
rows? Possible choices: "only_complete", "partly_complete",
"already_imputed", "all_except_i", "all_except_i_no_update", "all",
"all_no_update"}

\item{rows_order}{Ordering of the rows for imputation. This can be a vector with
indices or an \code{order_option} from \code{\link[=order_rows]{order_rows()}}.}

\item{M}{missing data indicator matrix}

\item{...}{Further arguments passed on to \code{initial_imputation_fun},
\code{stop_fun} and \code{\link[parsnip:reexports]{parsnip::fit_xy()}}, \code{\link[stats:predict]{stats::predict()}} used with the
\code{model_spec_parsnip}.}
}
\value{
an imputed data set.
}
\description{
Iterative imputation of a data set
}
\section{stop_fun}{
 The \code{stop_fun} should take the arguments \code{ds} (the data
set imputed in the current iteration), \code{ds_old} (the data set imputed in
the last iteration) and \code{M} in this order. Further arguments can be passed
on via \code{...}. The \code{stop_fun} must return \code{FALSE} to allow for a next
iteration. If \code{stop_fun} returns not \code{FALSE} the iteration is stopped and
the return value of \code{stop_fun} is returned as result of
\code{impute_iterative()}. Therefore, this return value should normally include
the imputed data set \code{ds} or \code{ds_old}.
}

\examples{
# ToDo
}
